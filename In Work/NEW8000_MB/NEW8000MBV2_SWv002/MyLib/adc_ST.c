//-----------------------------------------------------------------------------

#include "adc_ST.h"

//-----------------------------------------------------------------------------
//Настройка АЦП. 
void AdcInit(void){

	RCC->APB2ENR |= (RCC_APB2ENR_ADC1EN |  //Разрешить тактирование АЦП1.
                   RCC_APB2ENR_IOPCEN ); //Разрешить тактирование порта PORTC
  //--------------------	  
	GPIOC->CRL &= ~(GPIO_CRL_CNF0 | GPIO_CRL_MODE0 |	//PC0 - аналоговый вход.
									GPIO_CRL_CNF1 | GPIO_CRL_MODE1 |	//PC1 - аналоговый вход.
									GPIO_CRL_CNF2 | GPIO_CRL_MODE2 |	//PC2 - аналоговый вход.
									GPIO_CRL_CNF3 | GPIO_CRL_MODE3 |	//PC3 - аналоговый вход.
									GPIO_CRL_CNF4 | GPIO_CRL_MODE4 |	//PC4 - аналоговый вход.
									GPIO_CRL_CNF5 | GPIO_CRL_MODE5 );	//PC5 - аналоговый вход.
	//--------------------	
  RCC->CFGR &= ~RCC_CFGR_ADCPRE;		 //				
	RCC->CFGR |=  RCC_CFGR_ADCPRE_DIV8;//предделитель 8 (72МГц/8 = 9МГц).
  //предочистка регистра.
  ADC1->CR1  = 0;       
  ADC1->SQR1 = 0;
  ADC1->SQR3 = 0; 
  //Настройка работы АЦП.
  ADC1->CR2  =  ADC_CR2_EXTSEL;   //выбрать источником запуска разряд SWSTART
  ADC1->CR2 |= (ADC_CR2_EXTTRIG | //разр. внешний запуск регулярного канала
                ADC_CR2_ADON);    //включить АЦП
  //Рабочий вариант самокалибровки АЦП.  
  //Вычитать значение самокалибровки ненужно, АЦП это делает сам.
  ADC1->CR2 |= ADC_CR2_RSTCAL;         //Сброс калибровки
  while (ADC1->CR2 & ADC_CR2_RSTCAL){};//ждем окончания сброса
  ADC1->CR2 |= ADC_CR2_CAL;            //запуск калибровки 
  while (ADC1->CR2 & ADC_CR2_CAL){};   //ждем окончания калибровки 
}
//-----------------------------------------------------------------------------
//Одно измерение АЦП.
uint16_t AdcGetMeas(uint8_t channel){
  
  ADC1->SQR3 = (channel + 10);      //загрузить номер канала. 
                                    //+10 потому, что Poj1_AdcCh подключен к каналу 10 АЦП.
  ADC1->CR2 |= ADC_CR2_SWSTART;     //запуск преобразования в регулярном канале.
  while(!(ADC1->SR & ADC_SR_EOC)){};//дождаться окончания преобразования
  //Вычитать значение самокалибровки ненужно, АЦП это делает сам.
  return (uint16_t)((ADC1->DR * AdcQuant) / 10000);//(uint16_t)((ADC1->DR * 8068) / 10000); 
}
//-----------------------------------------------------------------------------









