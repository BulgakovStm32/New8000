
#include "Rtc.h"

//-----------------------------------------------------------------------------
static uint32_t 		TimeUtcFromMB;//Время принятое от ЦП
static TimeSTR_Type TimeSTR;      //
//-----------------------------------------------------------------------------
void	TimeInit(void){
	
	TimeSTR.year  = 0xCCBB;
	TimeSTR.month = 0xAA99;
	TimeSTR.day   = 0x8877;
	TimeSTR.hour  = 0x6655;
	TimeSTR.min   = 0x4433;
	TimeSTR.sec   = 0x2211;
	//TimeSTR.balast= 0xDD;
}
//-----------------------------------------------------------------------------
//Cохранение времени от ЦП.
void TimeFromMBSave(uint32_t time){
	
	TimeUtcFromMB = time;		
}
//-----------------------------------------------------------------------------
uint32_t TimeFromMBGet(void){

	return TimeUtcFromMB;
}
//-----------------------------------------------------------------------------
//Указатель на структуру календаря
TimeSTR_Type* DateAhdTimeGet(void){

	return &TimeSTR;
}
//-----------------------------------------------------------------------------
//функция преобразования значение счетчика в григорианскую дату и время 
void CounterToTimeAndDate(uint32_t counter){
	
	uint32_t a;
	uint8_t  b;
	uint8_t  d;
	uint8_t  m;
	//--------------------
	//a = (((counter + 43200)/(86400 >> 1)) + (JD0 << 1) + 1) >> 1;
	
	a = (((counter + 43200) / 43200) + JD) >> 1;
	
	TimeSTR.wday = a % 7;
	
	a += 32044;
	
	//a = (counter / 86400) + JD; //32044 + JD0;
	//a = ((counter + 43200)/86400) + JD; 
	
	b = (4 * a + 3) / 146097; // может ли произойти потеря точности из-за переполнения 4*ace ??	
	a = a - ((146097 * b) >> 2); // / 4);
	d = (4 * a + 3) / 1461;
	a = a - ((1461 * d) >> 2); // / 4);
	m = (5 * a + 2) / 153;
	
	TimeSTR.day   = a - ((153 * m + 2) / 5) + 1;
	TimeSTR.month = m + 3 - (12 * (m / 10));
	TimeSTR.year  = 100 * b + d - 4800 + (m / 10);
	TimeSTR.hour  = (uint16_t)((counter / 3600) % 24);
	TimeSTR.min   = (uint16_t)((counter / 60) % 60);
	TimeSTR.sec   = (uint16_t)(counter % 60);
}
//-----------------------------------------------------------------------------
// функция преобразования григорианской даты и времени в значение счетчика
uint32_t TimeAndDateToCounter(TimeSTR_Type* timeDate){
	
	uint8_t  a;
	uint16_t y;
	uint8_t  m;
	uint32_t JDN;
	//--------------------
	//Вычисление необходимых коэффициентов
	a = (14 - timeDate->month) / 12;
	y = timeDate->year  + 4800 - a;
	m = timeDate->month + (12 * a) - 3;
	//Вычисляем значение текущего Юлианского дня
	JDN  = timeDate->day - 1;
	JDN += (153 * m + 2) / 5;
	JDN += (365 * y);
	JDN += (y >> 2); // / 4);
	JDN -= (y / 100);
	JDN += (y / 400);
	JDN -= 32045; 
	JDN -= JD0;                  // так как счетчик у нас нерезиновый, уберем дни которые прошли до 01 янв 2001 
	JDN *= 86400;                // переводим дни в секунды
	JDN += timeDate->hour * 3600;// и дополняем его секундами текущего дня
	JDN += timeDate->min  * 60;
	JDN += timeDate->sec;
	
	return JDN;
}
//*************************************************************************************
//*************************************************************************************








