
#include "RTOS.h"

//-----------------------------------------------------------------------------

static volatile uint32_t RtosTickCount = 0;
			 volatile uint32_t TaskAdr;
//-----------------------------------------------------------------------------
//Диспетчер задач.
void RTOS_TaskManager(void){

  uint8_t index = 0;
  TPTR goToTask = Idle;
  //--------------------
  __disable_irq();	//Глобальное запрещение прерываний.
  //Прерывания надо запрещать потому, что идет обращение к глобальной очереди диспетчера. 
  //Ее могут менять и прерывания, поэтому заботимся об атомарности операции. 

	//Хватаем первое значение из очереди.
	goToTask = TaskQueue[0];
	//Проверка значения на корректность.
	if(((uint32_t)goToTask & 0xFFFF0000) != 0x08000000)
		{
			TaskQueue[0] = Idle;//Помещаем 
			__enable_irq();     //Глобальное разрешение прерываний.		
			(Idle)();			 
		}
  //Если там пусто то переходим на обработку пустого цикла
  else if(goToTask == Idle)		
    {
       __enable_irq();//Глобальное разрешение прерываний.		
      (Idle)();			  //пустой цикл
    }
  //В противном случае сдвигаем всю очередь
  else
   	{
      for(index = 0; index < TaskQueueSize; index++)	
        {
          TaskQueue[index] = TaskQueue[index+1];
        }	
      TaskQueue[TaskQueueSize] = Idle;//В последнюю запись пихаем затычку Idle
			//---------------		
			__enable_irq(); //Глобальное разрешение рерываний.	
				
			//--------
			//Отладка
			if(((uint32_t)goToTask & 0xFFFF0000) != 0x08000000)
				{
					TaskAdr = (uint32_t)goToTask;
				}
			//--------	
				
      (goToTask)();//Переходим к задаче
   	}
}
//---------------------------------------------------------
//Постановщик в очередь.
void RTOS_SetTask(TPTR task){

  uint8_t index = 0;
//	uint8_t noIRQ = 0;
  //--------------------
//  if (STATUS_REG & (1<<Interrupt_Flag))  // Если прерывания разрешены, то запрещаем их.
//    {
//      Disable_Interrupt
//      nointerrupted = 1;	// И ставим флаг, что мы не в прерывании.
//    }
//  // Это бодояга вида ATOMIС RESTORSTATE только собственной выделки с закосом под
//  // мультиплатформенность. Как видишь, тут SREG явно не указыватеся, он прописан в 
//  // дефайнах. При переносе на другой микроконтроллер, например, на С51 мне только 
//  // пару файлов поправить. А прерывания надо однозначно запретить. Ибо нужно
//  // обеспечить атомарность операций.
	
	//Отладка
	//if(((uint32_t)Task & 0xFFFF0000) != 0x08000000)debugReg = (uint32_t)TaskAdr;
	
  __disable_irq();//Глобальное запрещение прерываний.
  //noIRQ = 1;      //И ставим флаг, что мы не в прерывании.
  //А вот и постановка задачи в очередь.
  //Прочесываем очередь задач на предмет свободной ячейки со значением Idle.
  while(TaskQueue[index] != Idle)	
    {			
      index++;
      //Если очередь переполнена то выходим.
      if(index > TaskQueueSize)	
        {
          __enable_irq();//Если мы не в прерывании, то разрешаем прерывания
          return;		     //Можно вернуть код ошибки...
        }
    }
  // Если нашли свободное место, то
  TaskQueue[index] = task;//Записываем в очередь задачу
  __enable_irq();         //И включаем прерывания если не в обработчике прерывания.
}
//---------------------------------------------------------
//Прерывание таймера
//Служба таймеров пихается в обработчик прерывания от таймера. 
//Каким образом будет делаться прерывание это уже частности. 
//Можно повесить и на самый глупый таймер, например на таймер0. 

//Служба таймера.
void RTOS_TimerService(void){

  uint8_t index = 0;
  //--------------------
  RtosTickCount++;
  //--------------------
  //Прочесываем очередь таймеров
  //for(index = 0; index != MainTimerQueueSize + 1; index++) 
	for(index = 0; index < MainTimerQueueSize; index++) 
    {
      if(TaskWithTime[index].Task == Idle) continue;                 //Если нашли пустышку - щелкаем следующую итерацию
      if(TaskWithTime[index].Time > 1) TaskWithTime[index].Time -= 1;//Если таймер не выщелкал, то щелкаем еще раз.
      else//if(--MainTimer[index].Time == 0)//else //Дощелкали до нуля? Пихаем в очередь задачу
        {
          RTOS_SetTask(TaskWithTime[index].Task);//Дощелкали до нуля? Пихаем в очередь задачу
          TaskWithTime[index].Task = Idle;       //А в ячейку пишем затычку
        }
    }
}
//---------------------------------------------------------
uint32_t RTOS_GetTickCount(void){

  return RtosTickCount;
}
//---------------------------------------------------------
//Постановщик таймеров
void RTOS_SetTimerTask(TPTR task, uint16_t newTime){

  uint8_t index = 0;
  uint8_t noIRQ = 0;
  //-------------------- 
  // Проверка запрета прерывания, аналогично функции выше
//  if (STATUS_REG & (1<<Interrupt_Flag))    
//    {
//    Disable_Interrupt
//    nointerrupted = 1;
//    }
  __disable_irq();//Глобальное запрещение прерываний.
  noIRQ = 1;      //И ставим флаг, что мы не в прерывании.

  //Прочесываем очередь таймеров 
  for(index = 0; index < MainTimerQueueSize; index++)
    {
      if(TaskWithTime[index].Task == task)//Если уже есть запись с таким адресом
        {
          TaskWithTime[index].Time = newTime;//Перезаписываем ей выдержку
          if(noIRQ) __enable_irq();          //Разрешаем прерывания (если не были запрещены).
          return;          		               //Выходим. Раньше был код успешной операции. Пока убрал
        }
    }
  //Алгоритм, в данном случае не очень оптимален. В прошлом цикле можно было запомнить 
  //положение первого Idle и сейчас не искать его.
  for(index = 0; index < MainTimerQueueSize; index++)//Если не находим похожий таймер, то ищем любой пустой 
    {
      if(TaskWithTime[index].Task == Idle)  
        {
          TaskWithTime[index].Task = task;	 //Заполняем поле перехода задачи
          TaskWithTime[index].Time = newTime;//И поле выдержки времени
          if(noIRQ) __enable_irq();          //Разрешаем прерывания
          return; 					                 //Выход. 
        }
    }            
  // тут можно сделать return c кодом ошибки - нет свободных таймеров
}
//-----------------------------------------------------------------------------
//Инициализация диспетчера:
//В отличии от флагового автомата, где только флаги установить, 
//тут требуется при старте сделать инициализацию очередей и очистку таймеров.
//Функция выполняется один раз.
void RTOS_Init(void){

  uint8_t index;
  //--------------------
  //Во все позиции записываем Idle
  for(index = 0; index <= TaskQueueSize; index++)  
    {
      TaskQueue[index] = Idle;
			//Обнуляем все таймеры.
      TaskWithTime[index].Task = Idle;
      TaskWithTime[index].Time = 0;			
    }
  //Обнуляем все таймеры.
//	for(index = 0; index <= MainTimerQueueSize; index++) 
//		{
//			MainTimer[index].GoToTask = Idle;
//			MainTimer[index].Time     = 0;
//		}
}
//-----------------------------------------------------------------------------
//Запуск диспетчера. Собственно запускать то там надо таймер. 
//RTOS Запуск системного таймера
//void RTOS_Run(void){
//  
//  SysTickInit();
//}
//-----------------------------------------------------------------------------
//Пустая процедура - простой ядра. 
void Idle(void){
  
}
//-----------------------------------------------------------------------------
