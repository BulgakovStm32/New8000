
#include "RTOS.h"

//-----------------------------------------------------------------------------

volatile uint32_t RtosTickCount = 0;

//-----------------------------------------------------------------------------
//Диспетчер задач.
void RTOS_TaskManager(void){

  uint8_t index=0;
  TPTR    GoToTask = Idle;// Инициализируем переменные
  //--------------------
  // Как видишь, тут есть указатель Idle - ведущий на процедуру простоя ядра.
  // На нее можно повесить что нибудь совсем фоновое, например отладочные примочки =)  
  // И локальная переменная-указатель GoToTask куда мы будем жрать адреса переходов 

  //__disable_irq();	//Глобальное запрещение прерываний.
  //Прерывания надо запрещать потому, что идет обращение к глобальной очереди диспетчера. 
  //Ее могут менять и прерывания, поэтому заботимся об атомарности операции. 

  GoToTask = TaskQueue[0];// Хватаем первое значение из очереди.
  //Если там пусто то переходим на обработку пустого цикла
  if (GoToTask == Idle)		
    {
       //__enable_irq();//Глобальное разрешение прерываний.		
      (Idle)();			  //пустой цикл
    }
  //В противном случае сдвигаем всю очередь
  else
   	{
      for(index=0; index != TaskQueueSize; index++)	
        {
          TaskQueue[index] = TaskQueue[index+1];
        }	
      TaskQueue[TaskQueueSize] = Idle;//В последнюю запись пихаем затычку Idle
     // __enable_irq();	                //Глобальное разрешение рерываний.		
      (GoToTask)();		                //Переходим к задаче
   	}
}
//---------------------------------------------------------
//Постановщик в очередь.
void RTOS_SetTask(TPTR Task){

  uint8_t index = 0;
  uint8_t nointerrupted = 0;
  //--------------------
//  if (STATUS_REG & (1<<Interrupt_Flag))  // Если прерывания разрешены, то запрещаем их.
//    {
//      Disable_Interrupt
//      nointerrupted = 1;	// И ставим флаг, что мы не в прерывании.
//    }
//  // Это бодояга вида ATOMIС RESTORSTATE только собственной выделки с закосом под
//  // мультиплатформенность. Как видишь, тут SREG явно не указыватеся, он прописан в 
//  // дефайнах. При переносе на другой микроконтроллер, например, на С51 мне только 
//  // пару файлов поправить. А прерывания надо однозначно запретить. Ибо нужно
//  // обеспечить атомарность операций.
  __disable_irq();	//Глобальное запрещение прерываний.
  nointerrupted = 1;//И ставим флаг, что мы не в прерывании.

  //А вот и постановка задачи в очередь.
  //Прочесываем очередь задач на предмет 
  //свободной ячейки со значением Idle - конец очереди.
  while(TaskQueue[index]!=Idle)	
    {			
      index++;
      //Если очередь переполнена то выходим.
      if (index==TaskQueueSize+1)	
        {
          if (nointerrupted)  __enable_irq();//Если мы не в прерывании, то разрешаем прерывания
          return;		                         //Можно вернуть код ошибки...
        }
    }
  // Если нашли свободное место, то
  TaskQueue[index] = Task;		     //Записываем в очередь задачу
  if(nointerrupted) __enable_irq();//И включаем прерывания если не в обработчике прерывания.
}
//---------------------------------------------------------
//Прерывание таймера
//Служба таймеров пихается в обработчик прерывания от таймера. 
//Каким образом будет делаться прерывание это уже частности. 
//Я сделал на ШИМ таймере по достижении сравнения. 
//Впрочем, можно было повесить и на самый глупый таймер, например на таймер0, 
//который только тикать и умеет. А большего нам и не надо. 
//Но тут придется перезагружать его значение в каждом заходе, 
//чтобы поддерживать постоянное время. А на ШИМе это автоматом идет. 
//Разумеется вывод ШИМа не подключен к выводу контроллера. Тикает внутри.

//Служба таймера.
void RTOS_TimerService(void){

  uint8_t index = 0;
  //--------------------
  RtosTickCount++;
  //--------------------
  //Прочесываем очередь таймеров
  for(index = 0; index != MainTimerQueueSize+1; index++) 
    {
      //Если нашли пустышку - щелкаем следующую итерацию
      if(MainTimer[index].GoToTask == Idle) continue;
      //Если таймер не выщелкал, то щелкаем еще раз.
      if(MainTimer[index].Time !=1)	
        {			                      //To Do: Вычислить по тактам, что лучш;е !=1 или !=0.
          MainTimer[index].Time--;	//Уменьшаем число в ячейке если не конец.
        }
      else//if(--MainTimer[index].Time == 0)//else
        {
          RTOS_SetTask(MainTimer[index].GoToTask);//Дощелкали до нуля? Пихаем в очередь задачу
          MainTimer[index].GoToTask = Idle;       //А в ячейку пишем затычку
        }
    }
}
//---------------------------------------------------------
uint32_t RTOS_GetTickCount(void){

  return RtosTickCount;
}
//---------------------------------------------------------
//Постановщик таймеров
void RTOS_SetTimerTask(TPTR TS, uint16_t NewTime){

  uint8_t  index=0;
  uint8_t  nointerrupted = 0;
  //-------------------- 
  // Проверка запрета прерывания, аналогично функции выше
//  if (STATUS_REG & (1<<Interrupt_Flag))    
//    {
//    Disable_Interrupt
//    nointerrupted = 1;
//    }
  __disable_irq();	//Глобальное запрещение прерываний.
  nointerrupted = 1;//И ставим флаг, что мы не в прерывании.

  //Прочесываем очередь таймеров 
  for(index=0; index != MainTimerQueueSize+1; ++index)
    {
      if(MainTimer[index].GoToTask == TS)	  //Если уже есть запись с таким адресом
        {
          MainTimer[index].Time = NewTime;  //Перезаписываем ей выдержку
          if(nointerrupted)  __enable_irq();//Разрешаем прерывания (если не были запрещены).
          return;          		              //Выходим. Раньше был код успешной операции. Пока убрал
        }
   }
  //Алгоритм, в данном случае не очень оптимален. В прошлом цикле можно было запомнить 
  //положение первого Idle и сейчас не искать его.
  for(index=0; index != MainTimerQueueSize+1; ++index)//Если не находим похожий таймер, то ищем любой пустой 
    {
      if(MainTimer[index].GoToTask == Idle)  
        {
          MainTimer[index].GoToTask = TS;	    //Заполняем поле перехода задачи
          MainTimer[index].Time     = NewTime;//И поле выдержки времени
          if (nointerrupted) __enable_irq();  //Разрешаем прерывания
          return; 					                  //Выход. 
        }
    }            
  // тут можно сделать return c кодом ошибки - нет свободных таймеров
}
//-----------------------------------------------------------------------------
//Инициализация диспетчера:
//В отличии от флагового автомата, где только флаги установить, 
//тут требуется при старте сделать инициализацию очередей и очистку таймеров.
//Функция выполняется один раз.
void RTOS_Init(void){

  uint8_t index = 0;
  //--------------------
  //Во все позиции записываем Idle
  for(index=0; index != TaskQueueSize+1; index++)  
    {
      TaskQueue[index] = Idle;
    }
  //Обнуляем все таймеры.
  for(index=0; index != MainTimerQueueSize+1; index++) 
    {
      MainTimer[index].GoToTask = Idle;
      MainTimer[index].Time = 0;
    }
}
//-----------------------------------------------------------------------------
//Запуск диспетчера. Собственно запускать то там надо таймер. 
//RTOS Запуск системного таймера
void RTOS_Run(void){
  
  SysTickInit();
}
//-----------------------------------------------------------------------------
//Пустая процедура - простой ядра. 
void Idle(void){
  
}
//-----------------------------------------------------------------------------
